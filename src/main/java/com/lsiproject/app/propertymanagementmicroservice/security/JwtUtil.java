package com.lsiproject.app.propertymanagementmicroservice.security;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.security.Key;
import java.util.Arrays;
import java.util.Date;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Utility service for handling stateless JWT token operations:
 * Extraction of user claims (ID, Wallet Address, Roles) and validation.
 */
@Service
public class JwtUtil {

    // IMPORTANT: check .env for this value
    @Value("${application.security.jwt.secret-key}")
    private String secretKey;

    // We assume the token is generated by the Auth Service with these claims:
    private static final String USER_ID_CLAIM = "userId";
    private static final String ROLES_CLAIM = "roles";

    // ===================================
    // 1. EXTRACT CLAIMS (For Validation and Authentication)
    // ===================================

    /**
     * Extracts the wallet address (which is the subject) from the JWT token.
     */
    public String extractWalletAddress(String token) {
        // The wallet address is stored in the standard JWT 'subject' claim
        return extractClaim(token, Claims::getSubject);
    }

    /**
     * Extracts the custom user ID claim from the JWT token.
     */
    public Long extractUserId(String token) {
        // The ID is stored in a custom claim
        return extractClaim(token, claims -> claims.get(USER_ID_CLAIM, Long.class));
    }

    /**
     * Extracts the custom roles claim (comma-separated string) and converts it to a Set of strings.
     */
    public Set<String> extractRoles(String token) {
        String rolesString = extractClaim(token, claims -> claims.get(ROLES_CLAIM, String.class));
        if (rolesString == null || rolesString.isEmpty()) {
            return Set.of();
        }
        return Arrays.stream(rolesString.split(","))
                .map(String::trim)
                .collect(Collectors.toSet());
    }

    /**
     * Checks if the token is valid (not expired and signature is correct).
     * Since we are stateless, we only check the token itself, not against a database user.
     */
    public boolean isTokenValid(String token) {
        try {
            // If extracting claims fails (due to invalid signature, malformation, or expiry), it throws an exception.
            return !isTokenExpired(token);
        } catch (Exception e) {
            // Log for debugging (e.g., token expired, invalid signature)
            System.err.println("JWT Validation Error: " + e.getMessage());
            return false;
        }
    }

    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    // ===================================
    // 2. CORE UTILITY METHODS
    // ===================================

    /**
     * This method lets you read any specific piece of information inside the JWT payload.
     */
    private <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    /**
     * Takes your JWT token, Verifies its signature using your secret key => Returns the Claims object.
     */
    private Claims extractAllClaims(String token) {
        return Jwts
                .parserBuilder()
                .setSigningKey(getSignInKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    // Returns the Key object used to sign and verify tokens
    private Key getSignInKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secretKey);
        return Keys.hmacShaKeyFor(keyBytes);
    }

}